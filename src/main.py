# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'Main.ui'
#
# Created by: PyQt5 UI code generator 5.15.6
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

from enum import Enum
from time import perf_counter
from math import trunc, ceil, floor
import time

from PyQt5 import QtCore, QtGui, QtWidgets
from sdl2 import *
from sdl2.sdlttf import *

def check_bound(rectPoint, rectSize, point):
    checkX = point.x() >= rectPoint.x() and point.x() <= rectPoint.x() + rectSize.width()
    checkY = point.y() >= rectPoint.y() and point.y() <= rectPoint.y() + rectSize.height()
    return checkX and checkY

def plotPixel(surface, x, y, color):
    rt = SDL_Rect(x, y, 1, 1)
    SDL_FillRect(surface, rt, color)

def plotLineLow(surface, x0, y0, x1, y1, color):
    dx = x1 - x0
    dy = y1 - y0
    yi = 1
    if dy < 0:
        yi = -1
        dy = -dy
    D = (2 * dy) - dx
    y = y0

    for x in range(x0,x1+1):
        plotPixel(surface, x, y, color)
        if D > 0:
            y = y + yi
            D = D + (2 * (dy - dx))
        else:
            D = D + 2*dy

def plotLineHigh(surface, x0, y0, x1, y1, color):
    dx = x1 - x0
    dy = y1 - y0
    xi = 1
    if dx < 0:
        xi = -1
        dx = -dx
    D = (2 * dx) - dy
    x = x0

    for y in range(y0, y1+1):
        plotPixel(surface, x, y, color)
        if D > 0:
            x = x + xi
            D = D + (2 * (dx - dy))
        else:
            D = D + 2*dx

def plotLine(surface, source, dest, color):
    x0, y0 = source.x(), source.y()
    x1, y1 = dest.x(), dest.y()
     
    if abs(y1 - y0) < abs(x1 - x0):
        if x0 > x1:
            plotLineLow(surface, x1, y1, x0, y0, color)
        else:
            plotLineLow(surface, x0, y0, x1, y1, color)
    else:
        if y0 > y1:
            plotLineHigh(surface, x1, y1, x0, y0, color)
        else:
            plotLineHigh(surface, x0, y0, x1, y1, color)

class Graph:
    def minDistance(self,dist,queue):
        minimum = float("Inf")
        min_index = -1

        for i in range(len(dist)):
            if dist[i] < minimum and i in queue:
                minimum = dist[i]
                min_index = i
        return min_index

    def returnPath(self, parent, j):
        if parent[j] == -1 :
            return f"{j}"
        return f"{j} " + self.returnPath(parent , parent[j])
 
    def dijkstra(self, graph, src):
    
        iterateCount = 0

        row = len(graph)
        col = len(graph[0])

        dist = [float("Inf")] * row
 
        parent = [-1] * row
 
        dist[src] = 0
     
        queue = []
        for i in range(row):
            queue.append(i)
             
        while queue:
 
            u = self.minDistance(dist,queue)
  
            queue.remove(u)
 
            for i in range(col):

                if graph[u][i] and i in queue:
                    if dist[u] + graph[u][i] < dist[i]:
                        dist[i] = dist[u] + graph[u][i]
                        parent[i] = u
                iterateCount += 1

            iterateCount += 1
        return (dist, parent, iterateCount)

class Node:
    def __init__(self, id):
        self.position = QtCore.QPoint()
        self.id = id

class Link:
    def __init__(self, color):
        self.connects = False
        self.length = 0
        self.color = color

class GraphWidget(QtWidgets.QWidget):
    class DragState(Enum):
        none = 0
        node = 1
        surface = 2

    def __init__(self, parent = None):
        #constants
        self.dragLimitSet = 0.3
        self.nodeSize = QtCore.QSize(30, 30)
        self.poppins = TTF_OpenFont(bytes("Poppins.ttf", "utf-8"), 12)
        self.black = SDL_Color(0, 0, 0)

        #variables
        self.dragLimit = 0
        self.dragState = self.DragState.none
        self.dragNodeIdx = 0
        self.nodes = []
        self.links = []
        self.scale = 1.0

        self.prevMousePos = QtCore.QPoint()


        super().__init__(parent)

        
        self.le = QtWidgets.QLabel(self)

        self.surf = SDL_CreateRGBSurface(0, 550, 500, 32, 0, 0, 0, 0)

        self.bgColor = SDL_MapRGB(self.surf.contents.format.contents, 255, 255, 255)
        self.nodeColor = SDL_MapRGB(self.surf.contents.format.contents, 41, 211, 181)
        self.edgeColor = SDL_MapRGB(self.surf.contents.format.contents, 0, 0, 0)
        self.chosenEdgeColor = SDL_MapRGB(self.surf.contents.format.contents, 255, 0, 0)


        self.draw()


        # text = TTF_RenderText_Solid(self.poppins, bytes("1", "utf-8"), self.black)
        # SDL_BlitSurface(text, None, self.surf, None)
        # self.temp = 1
        # SDL_FreeSurface(surf)

    def addClickCallback(self, func):
        self.func = func

    def draw(self):
        SDL_FillRect(self.surf, None, self.bgColor)

        nodesToDraw = [None] * len(self.nodes)


        for idx, node in enumerate(self.nodes):
            nodesToDraw[idx] = Node(idx)
            nodesToDraw[idx].position = QtCore.QPoint(node.position.x(), node.position.y())
            nodesToDraw[idx].position.setX(trunc(nodesToDraw[idx].position.x() * self.scale))
            nodesToDraw[idx].position.setY(trunc(nodesToDraw[idx].position.y() * self.scale))

        drawSize = QtCore.QSize(trunc(self.nodeSize.width() * self.scale), 
                                trunc(self.nodeSize.height() * self.scale))

        #draw edges
        idx = 0
        while idx < len(self.links):
            link = self.links[idx]
            idx2 = idx+1

            while idx2 < len(link):
                eachNode = link[idx2]
                if eachNode.connects:
                    pos1 = QtCore.QPoint(nodesToDraw[idx].position.x(), nodesToDraw[idx].position.y())
                    pos1.setX(pos1.x() + self.nodeSize.width() // 2)
                    pos1.setY(pos1.y() + self.nodeSize.height() // 2)

                    pos2 = QtCore.QPoint(nodesToDraw[idx2].position.x(), nodesToDraw[idx2].position.y())
                    pos2.setX(pos2.x() + self.nodeSize.width() // 2)
                    pos2.setY(pos2.y() + self.nodeSize.height() // 2)
                    plotLine(self.surf, pos1, pos2, eachNode.color)


                    middlePoint = QtCore.QPoint((pos1.x() + pos2.x()) // 2, (pos1.y() + pos2.y()) // 2)
                    text = TTF_RenderText_Solid(self.poppins, bytes(f"{eachNode.length}", "utf-8"), self.black)
                    rt = SDL_Rect(middlePoint.x(), middlePoint.y(), self.nodeSize.width(), self.nodeSize.height())

                    SDL_BlitSurface(text, None, self.surf, rt)

                    SDL_FreeSurface(text)

                idx2 += 1

            idx += 1

        #draw nodes
        for node in nodesToDraw:
            rt = SDL_Rect(node.position.x(), node.position.y(), drawSize.width(), drawSize.height())
            SDL_FillRect(self.surf, rt, self.nodeColor)

            rt.x += trunc(rt.w / 2.5)
            rt.y += trunc(rt.h / 4)
            text = TTF_RenderText_Solid(self.poppins, bytes(f"{node.id}", "utf-8"), self.black)
            SDL_BlitSurface(text, None, self.surf, rt)

            SDL_FreeSurface(text)

        # for idx, link in enumerate(self.links):
        #     for idx2, eachNode in enumerate(link[idx+1:len(link)]):
        #         if eachNode.connects:
        #             plotLine(self.surf, self.nodes[idx].position, self.nodes[idx2].position, eachNode.color)


        img = QtGui.QImage(self.surf.contents.pixels, self.surf.contents.w, self.surf.contents.h, QtGui.QImage.Format_RGB32)
        pixMap = QtGui.QPixmap.fromImage(img)

        self.le.setPixmap(pixMap)

    def setLink(self, connects, source, dest):
        self.links[source][dest].connects = connects
        self.links[dest][source].connects = connects

    def setLinkLength(self, length, source, dest):
        self.links[source][dest].length = length
        self.links[dest][source].length = length

    def setLinkChosen(self, source, dest):
        self.links[source][dest].color = self.chosenEdgeColor
        self.links[dest][source].color = self.chosenEdgeColor

    def setLinkUnchosen(self, source, dest):
        self.links[source][dest].color = self.edgeColor
        self.links[dest][source].color = self.edgeColor

    def addNode(self):
        newNode = Node(len(self.nodes))
        self.nodes.append(newNode)

        newLink = [[Link(self.edgeColor) for i in range(len(self.nodes))] for i in range(len(self.nodes))]

        for idx, link in enumerate(self.links):
            for idx2, nodeLink in enumerate(link):
                newLink[idx][idx2] = nodeLink

        self.links = newLink

        self.draw()

        return newNode.id

    def removeNode(self, removeIdx):
        for i in range(len(self.nodes)):
            if i <= removeIdx:
                continue
            self.nodes[i].id -= 1

        self.nodes.pop(removeIdx)

        newLink = [[Link(self.edgeColor) for i in range(len(self.nodes))] for i in range(len(self.nodes))]

        outerI = 0
        for i in range(len(self.links)):
            if i == removeIdx:
                break
            outerJ = 0
            for j in range(len(self.links[i])):
                if j == removeIdx:
                    break
                newLink[outerI][outerJ] = self.links[i][j]
                outerJ += 1
            outerI += 1

        self.links = newLink

    def getLinks(self):
        return self.links

    def getNodes(self):
        return self.nodes

    def mousePressEvent(self, event):
        mousePos = event.pos()

        nodesToCheck = [None] * len(self.nodes)

        for idx, node in enumerate(self.nodes):
            nodesToCheck[idx] = Node(idx)
            nodesToCheck[idx].position = QtCore.QPoint(node.position.x(), node.position.y())
            nodesToCheck[idx].position.setX(trunc(nodesToCheck[idx].position.x() * self.scale))
            nodesToCheck[idx].position.setY(trunc(nodesToCheck[idx].position.y() * self.scale))

        for i in range(len(nodesToCheck)-1, -1, -1):
            node = nodesToCheck[i]
            if check_bound(node.position, self.nodeSize, mousePos):
                self.dragLimit = perf_counter()
                self.dragState = self.DragState.node
                self.dragNodeIdx = i
                return

        # for idx, node in enumerate(self.nodes[:-1]):
        #    if check_bound(node.position, self.nodeSize, mousePos):
        #       self.dragLimit = perf_counter()
        #       self.dragState = self.DragState.node
        #       self.dragNodeIdx = len(self.nodes) - idx - 1
        #       print(dragNodeIdx)
        self.dragState = self.DragState.surface
        self.prevMousePos = mousePos
        pass
        
    def mouseReleaseEvent(self, event):
        self.dragState = self.DragState.none
        if perf_counter() - self.dragLimit < self.dragLimitSet:
            self.func()
        pass

    def mouseMoveEvent(self, event):
        mousePos = event.pos()
        if self.dragState == self.DragState.node:
            if perf_counter() - self.dragLimit >= self.dragLimitSet:
                node = self.nodes[self.dragNodeIdx]
                node.position.setX(trunc(event.pos().x() / self.scale))
                node.position.setY(trunc(event.pos().y() / self.scale))
                self.draw()

        elif self.dragState == self.DragState.surface:
            movement = QtCore.QPoint()
            movement.setX(mousePos.x() - self.prevMousePos.x())
            movement.setY(mousePos.y() - self.prevMousePos.y())
            for node in self.nodes:
                node.position.setX(node.position.x() + movement.x())
                node.position.setY(node.position.y() + movement.y())

            self.prevMousePos = mousePos
            self.draw()
        pass

    def wheelEvent(self, event):
        adj = (event.angleDelta().y() / 120) * 0.1

        if self.scale <= 5 and adj > 0:
            self.scale += adj

        if self.scale >= 0.7 and adj < 0:
            self.scale += adj

        self.draw()
        pass


class Ui_Form(object):
    def setupUi(self, Form):
        Form.setObjectName("Djikstra")
        Form.resize(500, 500)
        Form.setMinimumSize(QtCore.QSize(800, 600))

        self.fileBtn = QtWidgets.QPushButton(Form)
        self.fileBtn.setGeometry(QtCore.QRect(20, 10, 111, 31))
        self.fileBtn.setObjectName("fileBtn")

        self.calculateBtn = QtWidgets.QPushButton(Form)
        self.calculateBtn.setGeometry(QtCore.QRect(150, 10, 111, 31))
        self.calculateBtn.setObjectName("calculateBtn")

        self.addNodeBtn = QtWidgets.QPushButton(Form)
        self.addNodeBtn.setGeometry(QtCore.QRect(300, 10, 111, 31))
        self.addNodeBtn.setObjectName("addNodeBtn")

        self.sourceNodeLabel = QtWidgets.QLabel(Form)
        self.sourceNodeLabel.setText("Source: ")
        self.sourceNodeLabel.setGeometry(300, 40, 100, 30)

        self.destNodeLabel = QtWidgets.QLabel(Form)
        self.destNodeLabel.setText("Destination: ")
        self.destNodeLabel.setGeometry(400, 40, 100, 30)

        self.iterateCountLabel = QtWidgets.QLabel(Form)
        self.iterateCountLabel.setText("Iterate Count: ")
        self.iterateCountLabel.setGeometry(525, 40, 100, 30)

        self.timeTakenLabel = QtWidgets.QLabel(Form)
        self.timeTakenLabel.setText("Time Taken: ")
        self.timeTakenLabel.setGeometry(625, 40, 150, 30)

        self.comboBox = QtWidgets.QComboBox(Form)
        self.comboBox.setObjectName("comboBox")
        self.comboBox.setGeometry(QtCore.QRect(10, 80, 190, 30))
        self.comboBox.currentIndexChanged.connect(lambda: self.comboBoxChanged())

        # self.verticalLayoutWidget = QtWidgets.QWidget(Form)
        # self.verticalLayoutWidget.setGeometry(QtCore.QRect(10, 120, 200, 401))
        # self.verticalLayoutWidget.setObjectName("verticalLayoutWidget")


        self.scrollArea = QtWidgets.QScrollArea(Form)
        self.scrollArea.setGeometry(QtCore.QRect(10, 120, 190, 401))
        self.scrollArea.setAlignment(QtCore.Qt.AlignTop)
        self.scrollArea.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAsNeeded)
        self.scrollArea.setWidgetResizable(True)

        self.scrollInner = QtWidgets.QWidget(self.scrollArea)

        self.scrollArea.setWidget(self.scrollInner)

        self.verticalLayout = QtWidgets.QVBoxLayout(self.scrollInner)
        self.verticalLayout.setContentsMargins(5, 5, 5, 5)
        self.verticalLayout.setObjectName("verticalLayout")
        self.verticalLayout.setAlignment(QtCore.Qt.AlignTop)

        self.graphWidget = GraphWidget(Form)
        self.graphWidget.setGeometry(QtCore.QRect(210, 80, 550, 500))
        self.graphWidget.setObjectName("graphWidget")
        self.graphWidget.addClickCallback(lambda: self.setDjikstra())

        self.checkboxes = []
        self.textInputs = []

        self.sourceNode = 0
        self.destinationNode = 0
        self.setSource = True

        self.retranslateUi(Form)
        QtCore.QMetaObject.connectSlotsByName(Form)

    def retranslateUi(self, Form):
        _translate = QtCore.QCoreApplication.translate
        Form.setWindowTitle(_translate("Form", "Form"))
        self.fileBtn.setText(_translate("Form", "Open File"))
        self.fileBtn.clicked.connect(lambda : self.getFile(Form))

        self.addNodeBtn.setText(_translate("Form", "Add Node"))
        self.addNodeBtn.clicked.connect(lambda: self.newNode())

        self.calculateBtn.setText(_translate("Form", "Calculate"))
        self.calculateBtn.clicked.connect(lambda: self.calculateDjikstra())

    def getFile(self, Form):
        fname = QtWidgets.QFileDialog.getOpenFileName(Form, "Open file")
        # print(fname[0])
        adjMatrix = []
        if fname[0] != '':
            with open(fname[0]) as file:
                for item in file:
                    temp = list(map(int, item.strip().split(" ")))
                    adjMatrix.append(temp)

        self.graphWidget.nodes = []
        self.graphWidget.links = []

        x = 0
        y = 0

        idx = 0
        tempCnt = 1

        for i in range(len(adjMatrix)):
            if tempCnt >=  ceil(len(adjMatrix) / 2):
                tempCnt = 0
                x = 0
                y += 60

            self.newNode()
            self.graphWidget.nodes[-1].position = QtCore.QPoint(x, y)

            x += 60

            tempCnt += 1


        for idx, iter1 in enumerate(adjMatrix):
            for idx2, iter2 in enumerate(iter1):
                self.graphWidget.setLink(True if iter2 > 0 else False, idx, idx2)
                self.graphWidget.setLinkLength(iter2, idx, idx2)

        self.comboBox.setCurrentIndex(0)
        self.comboBoxChanged()

        self.graphWidget.draw()

    def setDjikstra(self):
        if self.setSource:
            self.sourceNode = self.graphWidget.dragNodeIdx
            self.sourceNodeLabel.setText(f"source: {self.sourceNode}")
        else:
            self.destinationNode = self.graphWidget.dragNodeIdx
            self.destNodeLabel.setText(f"Destination: {self.destinationNode}")
        self.setSource = not self.setSource

    def calculateDjikstra(self):
        try:
            before = perf_counter()
            links = self.graphWidget.getLinks()
            graph = [[None for i in range(len(links))] for i in range(len(links))]

            for idx, link in enumerate(links):
                for idx2, eachNode in enumerate(link):
                    self.graphWidget.setLinkUnchosen(idx, idx2)
                    graph[idx][idx2] = int(eachNode.length) if eachNode.connects else 0

            g = Graph()

            temp = g.dijkstra(graph, self.sourceNode)
            path = g.returnPath(temp[1], self.destinationNode)

            pathList = list(map(int, path.split(" ")))
            for i in range(len(pathList)-1):
                self.graphWidget.setLinkChosen(pathList[i], pathList[i+1])
            
            after = perf_counter()
            diff = round((after - before) * 1000, 7)

            self.iterateCountLabel.setText(f"Iterate Count: {temp[2]}")
            self.timeTakenLabel.setText(f"Time Taken: {diff}ms")

            self.graphWidget.draw()
        except:
            pass

    def newNode(self):
        nodeId = self.graphWidget.addNode()
        self.comboBox.addItem(f"{nodeId}")

        self.setLinksInput()

    def removeNode(self, removeIdx):
        self.graphWidget.removeNode(removeIdx)
        self.graphWidget.draw()

        self.comboBox.clear()

        nodes = self.graphWidget.getNodes()

        for node in nodes:
            self.comboBox.addItem(f"{node.id}")
        pass

    def comboBoxChanged(self):
        self.setLinksInput()

    def checkBoxChanged(self, source):
        for idx, checkbox in enumerate(self.checkboxes):
            if idx == source:
                continue
            self.graphWidget.setLink(checkbox.isChecked(), source, idx)
        self.graphWidget.draw()

    def textInputChanged(self, source):
        for idx, textInput in enumerate(self.textInputs):
            if idx == source:
                continue
            self.graphWidget.setLinkLength(textInput.text(), source, idx)
        self.graphWidget.draw()

    def setLinksInput(self):
        links = self.graphWidget.getLinks()

        for i in reversed(range(self.verticalLayout.count())):
            self.verticalLayout.itemAt(i).widget().setParent(None)

        
        currentNode = self.comboBox.currentIndex()

        removeBtn = QtWidgets.QPushButton()
        removeBtn.setText("Remove this node")
        removeBtn.clicked.connect(lambda: self.removeNode(currentNode))

        self.verticalLayout.addWidget(removeBtn)

        self.checkboxes.clear()
        self.checkboxes = [None for i in range(len(links[currentNode]))]

        self.textInputs.clear()
        self.textInputs = [None for i in range(len(links[currentNode]))]

        for i, link in enumerate(links[currentNode]):
            if i == currentNode:
                continue

            horizontalLayoutWidget = QtWidgets.QWidget()

            horizontalLayout = QtWidgets.QHBoxLayout(horizontalLayoutWidget)

            label = QtWidgets.QLabel(f"{i}")

            textInput = QtWidgets.QLineEdit()
            textInput.setText(f"{link.length}")
            textInput.textChanged.connect(lambda: self.textInputChanged(currentNode))
            self.textInputs[i] = textInput

            checkbox = QtWidgets.QCheckBox()
            checkbox.setChecked(link.connects)
            checkbox.stateChanged.connect(lambda: self.checkBoxChanged(currentNode))
            self.checkboxes[i] = checkbox

            horizontalLayout.addWidget(label)
            horizontalLayout.addWidget(textInput)
            horizontalLayout.addWidget(checkbox)

            self.verticalLayout.addWidget(horizontalLayoutWidget)


class MainWindow(QtWidgets.QMainWindow):
    def __init__(self):
        super().__init__()
        ui = Ui_Form()
        ui.setupUi(self)

if __name__ == "__main__":
    import sys
    TTF_Init()
    app = QtWidgets.QApplication(sys.argv)

    splash_pix = QtGui.QPixmap('./img/logo.jpg')
    splash = QtWidgets.QSplashScreen(splash_pix, QtCore.Qt.WindowStaysOnTopHint)
    opaqueness = float(0.0)
    step = float(0.1)
    splash.setWindowOpacity(opaqueness)
    splash.show()
    while opaqueness < 1:
        splash.setWindowOpacity(opaqueness)
        time.sleep(step)
        opaqueness+=step
    time.sleep(1)
    splash.close()

    main_window = MainWindow()
    main_window.show()
    sys.exit(app.exec_())
